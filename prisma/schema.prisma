// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  // shadowDatabaseUrl = env("SHADOW_DATABASE_URL")  SOLO SE NECESITA CUANDO SE USA UN PROVEEDOR EN LA NUBE NO SOPORTA LA CREACION DE NUEVAS BASES DE DATOS COMO Heroku.
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// MODELO EXAMPLE

model Orchestra {
  id               String            @id @default(cuid()) // Podria declararse como tipo string @default(cuid()) ??? 
  name             String            @unique @db.VarChar()
  description      String
  logo             String?
  cover            String?
  creation_date    String
  sponsor          String?
  location         String
  is_active        Boolean?          @default(true)
  donation_account String            @unique
  phone            String            @unique
  createdAt        DateTime?         @default(now())
  updatedAt        DateTime?         @updatedAt
  user_id          String?
  posts            Post[]
  orchestra_type   Orchestra_Type?   @relation(fields: [orchestra_TypeId], references: [id])
  orchestra_TypeId String?
  Campaign         Campaign[]
  UserOnOrchestra  UserOnOrchestra[]
  favorites Favorites[]
}

model User {
  id                 String               @id @default(cuid())
  name               String?
  email              String               @unique
  password           String?
  avatar             String?
  cover              String?
  year_of_birth      String?
  city               String?
  is_active          Boolean              @default(true)
  first_time         Boolean              @default(true)
  comments           Comment[]
  posts              Post[]
  PostUserOnReaction PostUserOnReaction[]
  UserOnOrchestra    UserOnOrchestra[]
  Rol                Rol?                 @relation(fields: [rolId], references: [id])
  rolId              String?
  favorites Favorites[]
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
}

model Rol {
  id   String @id @default(cuid())
  name Roles @default(USER)
  User User[]
}

model Post {
  id                 String               @id @default(cuid())
  title              String
  content            String               @db.Text
  url_video          String?
  url_file           String?
  visibility         String?
  is_active          Boolean?              @default(true)
  creation_date      DateTime             @default(now())
  event_date         String?
  event_hour         String?
  views              Int?
  comments           Comment[]
  Orchestra          Orchestra          @relation(fields: [orchestraId], references: [id])
  orchestraId        String
  user               User               @relation(fields: [userCreator], references: [id])
  userCreator        String
  Type_Post          Type_Post?           @relation(fields: [type_PostId], references: [id])
  type_PostId        String?
  PostUserOnReaction PostUserOnReaction[]
}

model Orchestra_Type {
  id        String      @id @default(cuid())
  type      String
  Orchestra Orchestra[]
}

model Campaign {
  id            String    @id @default(cuid())
  title         String
  goal_amount   Float
  start_date    String
  end_date      String
  description   String    @db.Text
  is_active     Boolean   @default(true)
  amount_raised Float
  orchestra     Orchestra @relation(fields: [orchestraId], references: [id])
  orchestraId   String
}

model Comment {
  id            String   @id @default(cuid())
  content       String
  creation_date DateTime @default(now())
  is_active     Boolean  @default(true)
  User          User?    @relation(fields: [userId], references: [id])
  userId        String?
  Post          Post?    @relation(fields: [postId], references: [id])
  postId        String?
}

model Type_Post {
  id    String @id @default(cuid())
  name  String @unique
  posts Post[]
}

model Reaction {
  id                 String               @id @default(cuid())
  reaction           String               @unique
  PostUserOnReaction PostUserOnReaction[]
}

model PostUserOnReaction {
  post       Post     @relation(fields: [postId], references: [id])
  postId     String
  user       User     @relation(fields: [userId], references: [id])
  userId     String
  reaction   Reaction @relation(fields: [reactionId], references: [id])
  reactionId String

  @@id([postId, userId, reactionId])
}

model UserOnOrchestra {
  status      StatusOrchestraMember @default(PENDING)
  user        User                  @relation(fields: [userId], references: [id])
  userId      String
  orchestra   Orchestra             @relation(fields: [orchestraId], references: [id])
  orchestraId String
  type MemberType @default(BASIC)

  @@id([userId, orchestraId])
}

model Favorites {
  user User @relation(fields: [userId], references: [id])
  userId String
  orchestra Orchestra @relation(fields: [orchestraId], references: [id])
  orchestraId String

  @@id([userId,orchestraId])
}

enum StatusOrchestraMember {
  PENDING
  MEMBER
  REJECTED
}

enum MemberType {
  BASIC
  TEACHER
}

enum Roles {
  USER
  ADMIN
}

/////////////////////////////////////////////////////// PRISMA ADAPTER TEST ///////////////////////////////////////////////////////////////
model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?  @db.Text
  access_token       String?  @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?  @db.Text
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}